# Google test

Before running the google test, some preliminary operations were carried out using simulink tests to help its implementation.
First, the unit test was performed for each of the four subsystems that make up the Controller internally: TriggerPulseGenerator, FromEchoToDistance, DutyCicleGenerator and ErrorMonitoring. 
Functional testing is a quality assurance process: functions have been tested by providing input and examining the output.
Finally, the controller integration test was carried out to verify the functional correctness in the interactions between the different modules.
In both parts, the quality of the tests carried out in terms of coverage was verified. 

### Error monitoring

If the Distance input is between [2,400] [cm] or distance = 0 [cm], the expected error is 0. If instead Distance is <2 [cm] or distance> 400 [cm] then the error is 1.
It follows that the input can be partitioned into three equivalence classes: EQ1: Distance <2, EQ2 2 <= Distance <= 400, EQ3 Distance> 400.
For each of the equivalence classes and at the intersection points (2 and 400) a value was selected and then compared with the expected output.

### DutyCicleGenerator

We distinguish three equivalence classes and 3 intersection points:
EQ1: 10 <= Distance <= 100, EQ2: Distance <10, EQ3: Distance> 100, while for the intersections we identify distance = 10 [cm], distance = 100 [cm] and the case distance = 0 [cm].
To guarantee 100% coverage it was necessary to consider both “exit from ON state” and “exit from OFF state” in the states Blinker1, Blonker2, Blinker3.

### FromEchoToDistance

The input is an Echo signal with duration = distance * 58 [usec]. In this case, the equivalence class is unique: it is sufficient to generate any echo signal in the interval proportional to the distance between [0.450] [cm] (ie in the range of values driven by the knob).
Furthermore, the case distance = 0 [cm] (sensor disconnected) must also be considered.
Note: The expected distance value is delayed to take into account the time it takes for the subsystem to calculate the distance value.

### TriggerPulseGenerator

In this case, the value produced by stateflow was compared with that generated by the simulink Pulse Generator block. In particular, the block produces a square wave with a period of 100 [ms] and pulse width = 0.02%, that is 20 [usec].

### Test Harness Controller

Controller equivalence classes are a merge of the previous equivalence classes and their intersection points. In particular, considering X = distance we distinguish:
EQ1: 10 <= X <= 100, EQ2: 2 <= X <10, EQ3: 100 <X> = 400, EQ4: X = <2, EQ5: X> 400, EQ6: X = 0 and the intersection points X = 10 and X = 100, X = 2, X = 400.
Implementation notes 1: input: echo signal, output: corresponding blinking level. The controller has to translate the Echo signal into the distance. This operation takes time equal to the duration time of the echo signal itself. For these reasons, the subsystem that generates the expected blinking output must have a phase delay equal to this value.
Implementation Notes 2: The Workspace block writes the input signal data to a workspace. During the simulation, the Workspace block was used to collect the input and output data in the workspace. This data was then used for the google test.

### Google tests
  
At this point, starting from the simulink model, algorithm export was done and the corresponding C code (the same that will then be integrated with trampoline under posix) was obtained.
The ert_main.c file has been modified by adding the test function “test_ert_main”. This test function uses the data collected through the simulation in the previous point. In particular, these values have been stored in four textual files "input_echo.txt", "output_echo.txt", "output_trigger.txt" and "output_blinking.txt" which are read at each "feedback_control_step" to verify if given a "Feedback_contro_U_Echo" the values "feedback_contro_Y_Error", "feedback_contro_Y_Trigger" and "feedback_contro_Y_blinking" correspond to the expected values collected in the corresponding files. In fact, these last variables contain the input and output values of the model.
By doing so, it is possible on the one hand to verify the correctness of the test, and on the other hand to cross the program code in an exhaustive manner.

# Results

In terms of statemen/brach, a value of 97.1% and 86.6% was obtained respectively.
What is missing to reach 100% is exclusively due to the execution of the simulink Moving Average block used in the implementation of the model. Therefore, these are not lines of code written by the programmer, but initialization conditions and default correctness check.
  
<img width="1433" alt="Schermata 2021-07-22 alle 15 29 18" src="https://user-images.githubusercontent.com/57445485/126646992-2c379472-ecdd-4f7a-a880-8c5990e32b34.png">

