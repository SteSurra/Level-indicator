# Simulink project work-logic

There are two referenced subsystems interconnected: plant and controller.

## Plant

Plant containing a model of the ultrasonic ranging sensor whose essential parts are: 
1. Trigger signal that drives the start of the measurement.
2. Echo signal that represents the actual measurement.

The system receives two inputs:
1. Distance: the distance value is adjusted by means of a knob with values between [0-450] [cm]. Although the sensor can take measurements between [2-400] [cm] as reported in the specifications, the range of values chosen allows to test all the possible situations that may arise in the model.
2. Trigger: it is driven by the controller. It enables the system.

Describing in more detail, the plant is developed through a stateflow consisting of four states:
  
1. WAIT_TO_RISE is the starting state in which it remains until a high value of the trigger signal is received.
2. WAIT TO FALL: if the trigger value = 1 there are two possibilities: if the value remains high for at least 10 [usec], it moves towards the WAIT_TRIGGER_LOW state, otherwise it returns to the initial WAIT_TO_RISE state.
3. WAIT_TRIGGER_LOW: it remains in this state as long as the trigger signal remains high.
4. ENABLED: the Echo signal is generated as soon as the trigger signal goes low. The ENABLED state contains two further states: HIGH in which the Echo signal is generated proportional to the distance driven by the knob and LOW in which it passes as soon as the measurement is finished.

The time before passing to the LOW state is calculated by: 
```
time = distance * 58 [ùúáùë†]
```
and it represents the duration of the Echo signal expressed in ùúáùë†.

We note that no controls have been done to verify that the transition takes place within 100 [ms] (ie between one trigger instant and the next) since the high limit of 450 [cm] imposed by the knob precludes this possibility: 
```
450 * 58 = 26.1 [ms]. 
```
In a real case it should be considered.

Finally it returns to the initial state WAIT_TO_RISE.


## Controller

The controller is divided internally into 4 subsystems:

1. FromEchoToDistance receives the Echo signal in input and it outputs the corresponding distance measurement
2. DutyCycleGenerator receives in input the value of the distance generated by FromEchoToDistance and outputs the corresponding blinking
3. ErrorMonitoring receives in input the distance value generated by FromEchoToDistance and outputs the corresponding error signal
4. TriggerPulseGenerator is independent from the other subsystems and it generates the trigger signal that drives the plant

### FromEchoToDistance

The subsystem consists of a stateflow. In particular we distinguish two states:

1. INIT: it is the starting state in which it remains until the Echo signal is low. The Counter variable is initialized = 0.
2. WAIT_TO_FALL: this state is passed as soon as the Echo signal with a high value is received. In this state it remains until the value of Echo = 1. The Counter variable is incremented at each integration step.

It follows that as soon as the Echo value goes low, the count value will be equal to Echo pulse duration expressed in usec. At this point the distance in [cm] is obtained using the formula:
```
distance = counter / 58
```
Finally, it returns to the starting state INIT waiting for the next Echo signal.

We note that in the case of "no measurement" (distance = 0 or trigger signal <10 [ms]) the value of the Echo signal in input is always low: in this case if it remains in the INIT state for at least 100 [ms] (time period between one trigger signal and the next) then distance = 0 is output.

The distance value finally passes through the ‚ÄúMoving Average‚Äù simulink block which, through a sliding windows ‚Äù, acquires four consecutive measures and it computs the average.

No controls have been inserted to verify that a complete cycle takes place within 100 [ms] (ie between one trigger instant and the next) since the limit of 450 [cm] imposed by the knob precludes this possibility (450 * 58 = 26.1 [ ms]).

### DutyCycleGenerator

The subsystem consists of a stateflow. in particular, 4 states have been defined:

1. NO_BLINK: this is the default state.
2. BLINKER1: if the distance measurement is in the range [10,100], this state is reached. Inside there are two further states LED_ON and LED_OFF which respectively represent LEDs on and off. The transition from one state to another varies in relation to the distance value and a cycle is completed in 0.1 [s].
We note that in the case of distance = 100 [cm] we have no state transition from LED_ON to LED_OFF, but it remains in the LED_ON state. The reason is that 100 [cm] means a duty cycle = 100%. Finally, it returns to NO_BLINK as soon as the transition condition is no longer verified.

3. BLINKER2 is made similarly to BLINKER1. The transition into this state occurs if distance <10 [cm] or distance> 100 [cm].
Inside there are two further states LED_ON and LED_OFF in which the transition from one state to another occurs every 250 [ms] which means 0.5 [s] to complete a cycle. Also in this case, as soon as the initial condition is no longer valid, it returns to the starting state NO_BLINK.
4. BLINKER3 is similar to the two previous cases. However, we note that there is no transition condition since it is the last possible scenario: distance = 0 [cm] (i.e. sensor disconnected).
The transition from LED_ON to LED_OFF occurs every 500ms and one cycle is completed in 1 [s].

### ErrorMonitoring

The subsystem consists of a stateflow. In particular we distinguish 3 states:

1. RESET: is the initial state in which there are no errors (error = false) and in which it remains until the value of the distance received in input is included in the interval [2,400] cm. This range of values is the one reported in the datasheet of the ultrasonic ranging sensor HC_SR04
It follows that the out-of-range measurements have been calculated normally, but identified by an error signal.
We note that the distance value = 0 [cm] has not been reported as an error (even though it is out of range) because it falls within the case of "sensor disconnected".
2. CHECK_FOR_ERROR: a trigger pulse is generated every 100 [ms] and the distance value is an average of 4 consecutive measurements: if we get a value out of range before sending an error signal, it is verified that it is really. In fact, it is possible that it is a simple transient error. It follows that before reporting any error, a further 400 [ms] is waited and the next average is considered.
3. ERROR_STATE: if 400 [ms] have passed since the first report, then the error is reported.
We note that if we receive a further measurement out of range, we no longer have to wait for a further 400[ms]: if the previous measurement was wrong, it is assumed that the subsequent one is also wrong. On the other hand, if the new measurement is correct, it immediately returns to the initial RESET state.

### TriggerPulseGenerator

The trigger signal remains high for 20 [usec] and it is generated every 100[ms].

The subsystem consists of a stateflow. There are two states:

1. HIGH: the trigger value is set high.
2. LOW: the trigger value is set low.

## Technical specifications

In general, the integration step must be a submultiple of the trigger period: the choice made here was to use an integration step size of 1e-06 seconds in order to:
- Respect the above-specified constraint
- Get accurate measurements: the higher the integration step size, the lower the accuracy of the measurements.
